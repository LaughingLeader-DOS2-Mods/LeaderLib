Version 1
SubGoalCombiner SGC_AND
INITSECTION

KBSECTION

//REGION STATUS_CHECK
QRY
LeaderLib_Helper_QRY_HasStatus((GUIDSTRING)_Object, (STRING)_Status)
AND
HasAppliedStatus(_Object, _Status, 1)
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_HasStatus((GUIDSTRING)_Object, (STRING)_Status)
AND
HasActiveStatus(_Object, _Status, 1)
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_HasAnyStatus((GUIDSTRING)_Object, (STRING)_Status1, (STRING)_Status2)
AND
LeaderLib_Helper_QRY_HasStatus(_Object, _Status1)
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_HasAnyStatus((GUIDSTRING)_Object, (STRING)_Status1, (STRING)_Status2)
AND
LeaderLib_Helper_QRY_HasStatus(_Object, _Status2)
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_IsStunningStatus((STRING)_Status)
AND
GetStatusType(_Status, _Type)
AND
LeaderLib_Helper_QRY_Internal_IsStunningStatus(_Type)
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_Internal_IsStunningStatus("INCAPACITATED")
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_Internal_IsStunningStatus("KNOCKED_DOWN")
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_IsDamageStatus((STRING)_Status)
AND
GetStatusType(_Status, _Type)
AND
LeaderLib_Helper_QRY_Internal_IsDamageStatus(_Type)
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_Internal_IsDamageStatus("DAMAGE")
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_Internal_IsDamageStatus("DAMAGE_ON_MOVE")
THEN
DB_NOOP(1);

QRY
LeaderLib_Helper_QRY_HasPermanentStatus((GUIDSTRING)_Object, (STRING)_Status)
AND
LeaderLib_Helper_QRY_HasStatus(_Object, _Status)
AND
GetStatusTurns(_Object, _Status, _Turns)
AND
_Turns == -1
THEN
DB_NOOP(1);
//END_REGION

//Checks if the object is null before actually calling RemoveStatus
PROC
LeaderLib_Statuses_SafeRemoval((GUIDSTRING)_Object, (STRING)_Status)
AND
_Object != NULL_00000000-0000-0000-0000-000000000000
AND
ObjectExists(_Object, 1)
THEN
RemoveStatus(_Object, _Status);

PROC
LeaderLib_Statuses_RemoveIfActive((GUIDSTRING)_Object, (STRING)_Status)
AND
ObjectExists(_Object, 1)
AND
HasActiveStatus(_Object, _Status, 1)
THEN
RemoveStatus(_Object, _Status);

//REGION EXTEND_STATUS
//For applying a status and adding on top of the current turns, if any exists.
PROC
LeaderLib_Statuses_ExtendStatus((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns)
THEN
LeaderLib_Statuses_ExtendStatus(_Object, _Status, _AddTurns, 99, 1, _Object);

PROC
LeaderLib_Statuses_ExtendStatus((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns)
THEN
LeaderLib_Statuses_ExtendStatus(_Object, _Status, _AddTurns, _MaxTurns, 1, _Object);

PROC
LeaderLib_Statuses_ExtendStatus((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns, (INTEGER)_Force, (GUIDSTRING)_Source)
AND
NOT DB_LeaderLib_Statuses_Temp_ExtendResolved(_Object, _Status, _, _)
AND
HasActiveStatus(_Object, _Status, 1)
AND
GetStatusTurns(_Object, _Status, _Turns)
AND
_Turns >= 0
AND
IntegerSum(_Turns, _AddTurns, _NextTurns)
AND
IntegerMin(_NextTurns, _MaxTurns, _CappedTurns)
AND
Real(_CappedTurns, _DurationR)
AND
RealProduct(_DurationR, 6.0, _Duration)
THEN
ApplyStatus(_Object, _Status, _Duration, _Force, _Source);
DB_LeaderLib_Statuses_Temp_ExtendResolved(_Object, _Status, _Turns, _CappedTurns);

PROC
LeaderLib_Statuses_ExtendStatus((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns, (INTEGER)_Force, (GUIDSTRING)_Source)
AND
NOT DB_LeaderLib_Statuses_Temp_ExtendResolved(_Object, _Status, _, _)
AND
HasActiveStatus(_Object, _Status, 0)
AND
Real(_AddTurns, _DurationR)
AND
RealProduct(_DurationR, 6.0, _Duration)
THEN
ApplyStatus(_Object, _Status, _Duration, _Force, _Source);
DB_LeaderLib_Statuses_Temp_ExtendResolved(_Object, _Status, 0, _AddTurns);

PROC
LeaderLib_Statuses_ExtendStatus((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns, (INTEGER)_Force, (GUIDSTRING)_Source)
AND
DB_LeaderLib_Statuses_Temp_ExtendResolved(_Object, _Status, _LastTurns, _NextTurns)
THEN
NOT DB_LeaderLib_Statuses_Temp_ExtendResolved(_Object, _Status, _LastTurns, _NextTurns);
LeaderLib_Statuses_OnStatusExtended(_Object, _Status, _LastTurns, _NextTurns);

PROC
LeaderLib_Statuses_OnStatusExtended((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_LastTurns, (INTEGER)_NextTurns)
THEN
DB_NOOP(1);
//END_REGION

//REGION EXTEND_STATUS_DELAY

PROC
LeaderLib_Statuses_ExtendStatusWithDelay((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns)
THEN
LeaderLib_Statuses_ExtendStatusWithDelay(_Object, _Status, _AddTurns, 99, 1, _Object, 250, 0);

PROC
LeaderLib_Statuses_ExtendStatusWithDelay((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns)
THEN
LeaderLib_Statuses_ExtendStatusWithDelay(_Object, _Status, _AddTurns, _MaxTurns, 1, _Object, 250, 0);

PROC
LeaderLib_Statuses_ExtendStatusWithDelay((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns, (INTEGER)_Force, (GUIDSTRING)_Source, (INTEGER)_Delay, (INTEGER)_ResetTimer)
AND
NOT DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _, _, _, _, _)
AND
HasActiveStatus(_Object, _Status, 1)
AND
GetStatusTurns(_Object, _Status, _Turns)
AND
_Turns >= 0
AND
IntegerSum(_Turns, _AddTurns, _NextTurns)
AND
IntegerMin(_NextTurns, _MaxTurns, _CappedTurns)
THEN
DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _Turns, _CappedTurns, "", _Force, _Source);

PROC
LeaderLib_Statuses_ExtendStatusWithDelay((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns, (INTEGER)_Force, (GUIDSTRING)_Source, (INTEGER)_Delay, (INTEGER)_ResetTimer)
AND
NOT DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _, _, _, _ ,_)
AND
HasActiveStatus(_Object, _Status, 0)
AND
Real(_AddTurns, _DurationR)
AND
RealProduct(_DurationR, 6.0, _Duration)
THEN
DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, 0, _AddTurns, "", _Force, _Source);

PROC
LeaderLib_Statuses_ExtendStatusWithDelay((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns, (INTEGER)_Force, (GUIDSTRING)_Source, (INTEGER)_Delay, (INTEGER)_ResetTimer)
AND
DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _LastTurns, _Turns, _TimerName, _Force, _Source)
AND
_TimerName != ""
AND
IntegerSum(_Turns, _AddTurns, _NextTurns)
AND
IntegerMin(_NextTurns, _MaxTurns, _CappedTurns)
THEN
NOT DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _LastTurns, _Turns, _TimerName, _Force, _Source);
DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _LastTurns, _CappedTurns, _TimerName, _Force, _Source);

PROC
LeaderLib_Statuses_ExtendStatusWithDelay((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns, (INTEGER)_Force, (GUIDSTRING)_Source, (INTEGER)_Delay, (INTEGER)_ResetTimer)
AND
DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _LastTurns, _NextTurns, "", _Force, _Source)
AND
GetUUID(_Object, _Uuid)
AND
LeaderLog_QRY_Log("COMBINE", "LeaderLib_Timers_ExtendStatus_", _Status, "_", _Uuid)
AND
DB_LeaderLog_Temp_CombinedString(_TimerName)
THEN
NOT DB_LeaderLog_Temp_CombinedString(_TimerName); 
NOT DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _LastTurns, _NextTurns, "", _Force, _Source);
DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _LastTurns, _NextTurns, _TimerName, _Force, _Source);
TimerLaunch(_TimerName, _Delay);

PROC
LeaderLib_Statuses_ExtendStatusWithDelay((GUIDSTRING)_Object, (STRING)_Status, (INTEGER)_AddTurns, (INTEGER)_MaxTurns, (INTEGER)_Force, (GUIDSTRING)_Source, (INTEGER)_Delay, 1)
AND
DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _LastTurns, _NextTurns, _TimerName, _Force, _Source)
THEN
TimerCancel(_TimerName);
TimerLaunch(_TimerName, _Delay);

IF
TimerFinished(_TimerName)
AND
DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _LastTurns, _NextTurns, _TimerName, _Force, _Source)
AND
Real(_NextTurns, _DurationR)
AND
RealProduct(_DurationR, 6.0, _Duration)
THEN
NOT DB_LeaderLib_Statuses_Temp_ExtendDelayResult(_Object, _Status, _LastTurns, _NextTurns, _TimerName, _Force, _Source);
ApplyStatus(_Object, _Status, _Duration, _Force, _Source);
LeaderLib_Statuses_OnStatusExtended(_Object, _Status, _LastTurns, _NextTurns);
//END_REGION

//REGION LEAVE_ACTION_ITEMS

PROC
LeaderLib_Statuses_Register_LeaveActionProjectile((STRING)_ID, (STRING)_Status, (STRING)_Skill, (INTEGER)_ExplodeRadius)
THEN
DB_LeaderLib_Statuses_LeaveActionProjectile_Statuses(_ID, _Status, _Skill, _ExplodeRadius);

PROC
LeaderLib_Statuses_Register_LeaveActionProjectileBlacklist((STRING)_ID, (STRING)_IgnoreStatus)
THEN
DB_LeaderLib_Statuses_LeaveActionProjectile_Blacklist(_ID, _IgnoreStatus);

PROC
LeaderLib_Statuses_Clear_LeaveActionProjectiles((STRING)_ID)
AND
DB_LeaderLib_Statuses_LeaveActionProjectile_Statuses(_ID, _Status, _Skill, _ExplodeRadius)
THEN
NOT DB_LeaderLib_Statuses_LeaveActionProjectile_Statuses(_ID, _Status, _Skill, _ExplodeRadius);

PROC
LeaderLib_Statuses_Clear_LeaveActionProjectileBlacklist((STRING)_ID)
AND
DB_LeaderLib_Statuses_LeaveActionProjectile_Blacklist(_ID, _IgnoreStatus)
THEN
NOT DB_LeaderLib_Statuses_LeaveActionProjectile_Blacklist(_ID, _IgnoreStatus);


/* LeaveAction/EXPLODE on statuses do not work on items. This is a workaround so it does.
Enable the toggle script via:
LeaderLib_ToggleScripts_EnableScript("LeaderLib_LeaveActionItemFixEnabled", "ModName");
Or call this proc manually.
*/
PROC
LeaderLib_Statuses_ExplodeProjectile((ITEMGUID)_Target, (GUIDSTRING)_Source, (STRING)_ProjectileSkill, (INTEGER)_ExplodeRadius)
AND
ObjectIsCharacter((CHARACTERGUID)_Source, 1)
AND
_ExplodeRadius > 0
THEN
CharacterItemSetEvent(_Source, _Target, "LeaderLib_LeaveAction_ExplodeProjectile");

PROC
LeaderLib_Statuses_ExplodeProjectile((ITEMGUID)_Target, (GUIDSTRING)_Source, (STRING)_ProjectileSkill, (INTEGER)_ExplodeRadius)
AND
ObjectIsCharacter((CHARACTERGUID)_Source, 1)
AND
_ExplodeRadius <= 0
THEN
CharacterItemSetEvent(_Source, _Target, "LeaderLib_LeaveAction_ShootProjectile");

PROC
LeaderLib_Statuses_ExplodeProjectile((ITEMGUID)_Target, (GUIDSTRING)_Source, (STRING)_ProjectileSkill, (INTEGER)_ExplodeRadius)
AND
ObjectIsCharacter(_Source, 0)
AND
_ExplodeRadius > 0
THEN
SetVarObject(_Target, "LeaderLib_LeaveAction_Source", _Source);
SetStoryEvent(_Target, "LeaderLib_LeaveAction_ExplodeProjectile");

PROC
LeaderLib_Statuses_ExplodeProjectile((ITEMGUID)_Target, (GUIDSTRING)_Source, (STRING)_ProjectileSkill, (INTEGER)_ExplodeRadius)
AND
ObjectIsCharacter(_Source, 0)
AND
_ExplodeRadius <= 0
THEN
SetVarObject(_Target, "LeaderLib_LeaveAction_Source", _Source);
SetStoryEvent(_Target, "LeaderLib_LeaveAction_ShootProjectile");
//END_REGION
EXITSECTION

ENDEXITSECTION
ParentTargetEdge "LaughingLeader__LeaderLib"