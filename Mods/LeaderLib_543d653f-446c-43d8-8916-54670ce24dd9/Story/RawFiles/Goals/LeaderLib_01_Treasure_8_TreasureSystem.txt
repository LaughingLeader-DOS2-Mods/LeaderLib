Version 1
SubGoalCombiner SGC_AND
INITSECTION
//REGION REGISTERED
//DB_LeaderLib_Treasure_RegisteredObject(_TreasureID, _Object)
//DB_LeaderLib_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
//DB_LeaderLib_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
//DB_LeaderLib_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)

//DB_LeaderLib_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID)
//DB_LeaderLib_Treasure_TreasureItemStats(_TreasureID, _ItemEntry, _Amount, _RequirementID)
//DB_LeaderLib_Treasure_ItemLevel(_TreasureID, _ItemEntry, _MinLevel, _MaxLevel, _UsePartyLevel)
//DB_LeaderLib_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _GenerationType)
//DB_LeaderLib_Treasure_RegisteredGenerationTypes(_GenerationType)
//DB_LeaderLib_Treasure_ItemGenerationFlag(_TreasureID, _ItemEntry, _Flag, _FlagType)
//DB_LeaderLib_Treasure_ItemDeltaMods(_TreasureID, _ItemEntry, _Deltamod, _Chance)
//DB_LeaderLib_Treasure_ItemRunes(_TreasureID, _ItemEntry, _Rune, _Chance)
//DB_LeaderLib_Treasure_ItemMaxAmount(_TreasureID, _ItemEntry, _MaxAmount)

//DB_LeaderLib_Treasure_OnlyOnce(_TreasureID, _ItemEntryOrTreasureTable, _OnCompletionEvent)
//DB_LeaderLib_Treasure_GeneratedEvent(_TreasureID, _ItemEntry, _OnGeneratedEvent)
//DB_LeaderLib_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
//END_REGION
//DB_LeaderLib_Treasure_StatToTemplate(_ItemEntry, _ItemTemplate)
//DB_LeaderLib_Treasure_GeneratorDummies(_Dummy)

//DB_LeaderLib_Treasure_Temp_DummyTarget(_Object, _Dummy, _TreasureID, _ItemEntry, _DummyID, _QueueEntryID)
//DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
//DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
//DB_LeaderLib_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID)
//DB_LeaderLib_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID)
//DB_LeaderLib_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate)
//DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _CreatedAmount, _MaxAmount, _IsStat)
//DB_LeaderLib_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID)
//DB_LeaderLib_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID)
/*GENERATION_QUEUE*/
//DB_LeaderLib_Array_Data("LeaderLib_ItemGenerationQueue", _Index, _ID)
//DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType)
//DB_LeaderLib_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID)
//DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
//DB_LeaderLib_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat)
KBSECTION
//REGION GETTERS
QRY
LeaderLib_Treasure_QRY_GetTreasureID((GUIDSTRING)_Object)
AND
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
NOT DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureID((GUIDSTRING)_Object)
AND
DB_LeaderLib_Treasure_RegisteredObject(_TreasureID, _Object)
THEN
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureID((GUIDSTRING)_Object)
AND
GetTemplate(_Object, _Template)
AND
DB_LeaderLib_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
THEN
DB_LeaderLib_Treasure_Temp_MatchedTreasure((GUIDSTRING)_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureID((GUIDSTRING)_Object)
AND
DB_LeaderLib_Traders_Active((CHARACTERGUID)_Object, _TraderID, _Level)
AND
DB_LeaderLib_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
THEN
DB_LeaderLib_Treasure_Temp_MatchedTreasure((GUIDSTRING)_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID, (STRING)_GenerationType)
THEN
LeaderLib_Treasure_Internal_GetTreasureObject_ClearPreviousTemp(_TreasureID, _GenerationType);

PROC
LeaderLib_Treasure_Internal_GetTreasureObject_ClearPreviousTemp((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType)
THEN
NOT DB_LeaderLib_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType);

PROC
LeaderLib_Treasure_Internal_GetTreasureObject_ClearPreviousTemp((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
NOT DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_RegisteredObject(_TreasureID, _Object)
THEN
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
AND
DB_LeaderLib_Traders_Active(_Trader, _TraderID, _Level)
THEN
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Trader, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
AND
NOT DB_LeaderLib_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType)
THEN
DB_LeaderLib_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem] Launching iterators to find object with template [",_Template,"] for [",_TreasureID,":",_GenerationType,"]");
CharacterLaunchIterator("LeaderLib_Events_Treasure_FindObject");
ItemLaunchIterator("LeaderLib_Events_Treasure_FindObject");

IF
StoryEvent(_Object, "LeaderLib_Events_Treasure_FindObject")
AND
GetTemplate(_Object, _Template)
AND
DB_LeaderLib_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType)
THEN
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);
LeaderLib_SendEvent("LeaderLib_Events_Treasure_ContinueGeneration");

/*
IF
StoryEvent(NULL_00000000-0000-0000-0000-000000000000, "LeaderLib_Events_Treasure_FindObject")
AND
DB_LeaderLib_Treasure_Temp_MatchTemplate(_TreasureID, _Template)
THEN
NOT DB_LeaderLib_Treasure_Temp_MatchTemplate(_TreasureID, _Template);
*/

QRY
LeaderLib_Treasure_QRY_GetTreasureObject((STRING)_TreasureID)
AND
NOT DB_LeaderLib_Treasure_Temp_MatchedTreasure(_, _TreasureID)
AND
DB_LeaderLib_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
AND
DB_LeaderLib_Traders_Active(_Object, _TraderID, _Level)
THEN
DB_LeaderLib_Treasure_Temp_MatchedTreasure((GUIDSTRING)_Object, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByGenerationType((STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID)
THEN
NOT DB_LeaderLib_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByGenerationType((STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
AND
NOT DB_LeaderLib_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID)
THEN
DB_LeaderLib_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByGenerationType((STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _GenerationType)
AND
NOT DB_LeaderLib_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID)
THEN
DB_LeaderLib_Treasure_Temp_GenerationTypeToTreasure(_GenerationType, _TreasureID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByRequirement((STRING)_RequirementID)
AND
DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
NOT DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByRequirement((STRING)_RequirementID)
AND
DB_LeaderLib_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID)
AND
NOT DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByRequirement((STRING)_RequirementID)
AND
DB_LeaderLib_Treasure_TreasureItemStats(_TreasureID, _ItemEntry, _Amount, _RequirementID)
AND
NOT DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);

QRY
LeaderLib_Treasure_QRY_GetTreasureByRequirement((STRING)_RequirementID)
AND
DB_LeaderLib_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
NOT DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);
//END_REGION

//REGION QUERIES_CHECKS
QRY
LeaderLib_Treasure_QRY_IsRegisteredObject((GUIDSTRING)_Object)
AND
DB_LeaderLib_Treasure_RegisteredObject(_TreasureID, _Object)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_IsRegisteredObject((CHARACTERGUID)_Object)
AND
DB_LeaderLib_Traders_Active(_Object, _TraderID, _Level)
AND
DB_LeaderLib_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_IsRegisteredObject((GUIDSTRING)_Object)
AND
NOT DB_LeaderLib_Treasure_RegisteredObject(_, _Object)
AND
GetTemplate(_Object, _Template)
AND
DB_LeaderLib_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_GenerationTypeIsDefault("DEFAULT")
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_GenerationTypeIsDefault("REGISTERED")
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_GenerationTypeIsDefault("MANUAL")
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_GenerationTypeIsDefault("OPENED")
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_GenerationTypeIsDefault("TRADE_GENERATION_END")
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureHasItemsToGenerate((STRING)_TreasureID, (STRING)_GenerationType)
AND
NOT DB_LeaderLib_Treasure_Temp_FoundItem(_TreasureID)
AND
DB_LeaderLib_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _ItemEntry, _RequirementID, _GenerationType)
THEN
DB_LeaderLib_Treasure_Temp_FoundItem(_TreasureID);

QRY
LeaderLib_Treasure_QRY_TreasureHasItemsToGenerate((STRING)_TreasureID, (STRING)_GenerationType)
AND
NOT DB_LeaderLib_Treasure_Temp_FoundItem(_TreasureID)
AND
DB_LeaderLib_Treasure_TreasureItemStats(_TreasureID, _ItemEntry, _Amount, _RequirementID)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _ItemEntry, _RequirementID, _GenerationType)
THEN
DB_LeaderLib_Treasure_Temp_FoundItem(_TreasureID);

QRY
LeaderLib_Treasure_QRY_TreasureHasItemsToGenerate((STRING)_TreasureID, (STRING)_GenerationType)
AND
NOT DB_LeaderLib_Treasure_Temp_FoundItem(_TreasureID)
AND
DB_LeaderLib_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _TreasureTable, _RequirementID, _GenerationType)
THEN
DB_LeaderLib_Treasure_Temp_FoundItem(_TreasureID);

QRY
LeaderLib_Treasure_QRY_TreasureHasItemsToGenerate((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_Temp_FoundItem(_TreasureID)
THEN
NOT DB_LeaderLib_Treasure_Temp_FoundItem(_TreasureID);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerateWithType((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerateWithType((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_GenerationType)
AND
NOT DB_LeaderLib_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _)
AND
DB_LeaderLib_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerateWithType((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_GenerationType)
AND
NOT DB_LeaderLib_Treasure_ItemGenerationType(_TreasureID, _ItemEntry, _)
AND
NOT DB_LeaderLib_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
AND
LeaderLib_Treasure_QRY_GenerationTypeIsDefault(_GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerate((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_RequirementID, "MANUAL")
AND
LeaderLib_Requirements_QRY_AllMet(_RequirementID)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ItemCanGenerate((STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_RequirementID, (STRING)_GenerationType)
AND
_GenerationType != "MANUAL"
AND
LeaderLib_Treasure_QRY_ItemCanGenerateWithType(_TreasureID, _ItemEntry, _GenerationType)
AND
LeaderLib_Requirements_QRY_AllMet(_RequirementID)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureHasGenerationType((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureHasGenerationType((STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_ItemGenerationType(_TreasureID, _, _GenerationType)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureMatch((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LeaderLib_Treasure_RegisteredObject(_TreasureID, _Object)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureMatch((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
GetTemplate(_Object, _Template)
AND
DB_LeaderLib_Treasure_RegisteredObjectTemplate(_TreasureID, _Template)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreasureMatch((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LeaderLib_Traders_Active((CHARACTERGUID)_Object, _TraderID, _Level)
AND
DB_LeaderLib_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
THEN
DB_NOOP(1);
//END_REGION

//REGION TREASURE_TABLE_QUERIES
//Default to 1
QRY
LeaderLib_Treasure_QRY_TreaureTableLimitReached((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT DB_LeaderLib_Treasure_TreasureTableLimit(_TreasureID, _TreasureTable, _)
AND
IsTagged(_Object, "LeaderLib_DisableTreasureTableLimit", 0)
AND
DB_LeaderLib_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _Count)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_TreaureTableLimitReached((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
DB_LeaderLib_Treasure_TreasureTableLimit(_TreasureID, _TreasureTable, _Limit)
AND
_Limit > 0
AND
DB_LeaderLib_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _Count)
AND
_Count >= _Limit
THEN
DB_NOOP(1);
//END_REGION

//REGION TREASURE_TABLE_GENERATION
PROC
LeaderLib_Treasure_GenerateItems((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
NOT LeaderLib_Treasure_QRY_TreaureTableLimitReached(_Object, _TreasureID, _TreasureTable)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _TreasureTable, _RequirementID, _GenerationType)
THEN
LeaderLib_Treasure_Internal_ProcessTreasureTable(_ID, _Object, _TreasureID, _GenerationType, _TreasureTable, _UsePartyLevel, _MinLevel, _MaxLevel);

PROC
LeaderLib_Treasure_Internal_ProcessTreasureTable((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType, (STRING)_TreasureTable, (INTEGER)_UsePartyLevel, (INTEGER)_MinLevel, (INTEGER)_MaxLevel)
AND
NOT DB_LeaderLib_Treasure_Temp_TableGenerated(_Object, _TreasureID, _TreasureTable)
AND
_UsePartyLevel > 0
AND
CharacterGetHostCharacter(_Player) // The invisible backpack has 'UsePartyLevelForTreasure' checked.
THEN
DB_LeaderLib_Treasure_Temp_TableGenerated(_Object, _TreasureID, _TreasureTable);
LeaderLib_Treasure_Internal_GenerateTreasureTable(_ID, _Object, _TreasureID, _GenerationType, -1, _TreasureTable, _Player);

PROC
LeaderLib_Treasure_Internal_ProcessTreasureTable((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType, (STRING)_TreasureTable, (INTEGER)_UsePartyLevel, (INTEGER)_MinLevel, (INTEGER)_MaxLevel)
AND
NOT DB_LeaderLib_Treasure_Temp_TableGenerated(_Object, _TreasureID, _TreasureTable)
AND
_UsePartyLevel <= 0
AND
_MinLevel > -1
AND
_MaxLevel > -1
AND
LeaderLib_Random_QRY(_MinLevel, _MaxLevel)
AND
DB_LeaderLib_Random(_Level)
THEN
NOT DB_LeaderLib_Random(_Level);
DB_LeaderLib_Treasure_Temp_TableGenerated(_Object, _TreasureID, _TreasureTable);
LeaderLib_Treasure_Internal_GenerateTreasureTable(_ID, _Object, _TreasureID, _GenerationType, _Level, _TreasureTable, NULL_00000000-0000-0000-0000-000000000000);

PROC
LeaderLib_Treasure_Internal_ProcessTreasureTable((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType, (STRING)_TreasureTable, (INTEGER)_UsePartyLevel, (INTEGER)_MinLevel, (INTEGER)_MaxLevel)
AND
NOT DB_LeaderLib_Treasure_Temp_TableGenerated(_Object, _TreasureID, _TreasureTable)
AND
_UsePartyLevel <= 0
AND
_MinLevel <= -1
AND
_MaxLevel <= -1
AND
CharacterGetHostCharacter(_Player)
THEN
DB_LeaderLib_Treasure_Temp_TableGenerated(_Object, _TreasureID, _TreasureTable);
LeaderLib_Treasure_Internal_GenerateTreasureTable(_ID, _Object, _TreasureID, _GenerationType, -1, _TreasureTable, _Player);

PROC
LeaderLib_Treasure_Internal_ProcessTreasureTable((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType, (STRING)_TreasureTable, (INTEGER)_UsePartyLevel, (INTEGER)_MinLevel, (INTEGER)_MaxLevel)
AND
DB_LeaderLib_Treasure_Temp_TableGenerated(_Object, _TreasureID, _TreasureTable)
THEN
NOT DB_LeaderLib_Treasure_Temp_TableGenerated(_Object, _TreasureID, _TreasureTable);

PROC
LeaderLib_Treasure_Internal_GenerateTreasureTable((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType, (INTEGER)_Level, (STRING)_TreasureTable, (CHARACTERGUID)_Player)
AND
GetPosition(_Object, _x, _y, _z)
AND
CreateItemTemplateAtPosition("LOOT_LeaderLib_BackPack_Invisible_98fa7688-0810-4113-ba94-9a8c8463f830", _x, _y, _z, _Backpack)
THEN
SetTag(_Backpack, "LeaderLib_Internal_TreasureTableContainer");
DB_LeaderLib_Treasure_Temp_TreasureTableBackpack(_Object, _Backpack, _TreasureID, _TreasureTable, _ID);
GenerateTreasure(_Backpack, _TreasureTable, _Level, _Player);
//LeaderLib_Timers_StartObjectTimer(_Backpack, 100, "LeaderLib_Timers_Internal_MoveTreasureTableItems_", "LeaderLib_Events_Internal_MoveTreasureTableItems");
SetStoryEvent(_Backpack, "LeaderLib_Events_Internal_MoveTreasureTableItems"); // So the ItemAdded events can fire first

IF
ItemAddedToContainer(_Item, _Backpack)
AND
IsTagged(_Backpack, "LeaderLib_Internal_TreasureTableContainer", 1)
AND
DB_LeaderLib_Treasure_Temp_TreasureTableBackpack(_Object, _Backpack, _TreasureID, _TreasureTable, _ID)
THEN
LeaderLib_Treasure_Internal_CheckPostGenBonusesForTable(_Object, _Item, _TreasureID, _TreasureTable);

PROC
LeaderLib_Treasure_Internal_CheckPostGenBonusesForTable((GUIDSTRING)_Object, (ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT LeaderLib_Treasure_QRY_TreasureTableUsesTemplates(_TreasureID, _TreasureTable)
AND
GetStatString(_Item, _ItemEntry)
AND
LeaderLib_Treasure_QRY_HasPostGenerationBonuses(_TreasureID, _ItemEntry)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ItemAddedToContainer(TreasureTableContainer:Stat)] Item [",_ItemEntry,"] generated from treasure [",_TreasureID,"] with table [",_TreasureTable,"] has post-gen bonuses.");
DB_LeaderLib_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry);

PROC
LeaderLib_Treasure_Internal_CheckPostGenBonusesForTable((GUIDSTRING)_Object, (ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
LeaderLib_Treasure_QRY_TreasureTableUsesTemplates(_TreasureID, _TreasureTable)
AND
GetTemplate(_Item, _ItemEntry)
AND
LeaderLib_Treasure_QRY_HasPostGenerationBonuses(_TreasureID, _ItemEntry)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ItemAddedToContainer(TreasureTableContainer:Template)] Item [",_ItemEntry,"] generated from treasure [",_TreasureID,"] with table [",_TreasureTable,"] has post-gen bonuses.");
DB_LeaderLib_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry);

IF
StoryEvent((ITEMGUID)_Backpack, "LeaderLib_Events_Internal_MoveTreasureTableItems")
AND
DB_LeaderLib_Treasure_Temp_TreasureTableBackpack(_Object, _Backpack, _TreasureID, _TreasureTable, _ID)
THEN
NOT DB_LeaderLib_Treasure_Temp_TreasureTableBackpack(_Object, _Backpack, _TreasureID, _TreasureTable, _ID);
MoveAllItemsTo(_Backpack, _Object, 0, 0, 1);
ItemRemove(_Backpack);
LeaderLib_Treasure_Internal_IncreaseTreasureTableCount(_Object, _TreasureID, _TreasureTable);
LeaderLib_Treasure_Internal_OnTreasureTableGenerated(_ID, _Object, _TreasureID, _TreasureTable);

PROC
LeaderLib_Treasure_Internal_OnTreasureTableGenerated((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT DB_LeaderLib_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _, _, _, _, _)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:OnTreasureTableGenerated] Generated treasure table [",_TreasureTable,"] for treasure [",_TreasureID,"].");
//LeaderLib_Treasure_Internal_MarkTreasureAsFinished(_ID, _Object, _TreasureID);
LeaderLib_Treasure_Internal_MarkItemAsFinished(_ID, _Object, _TreasureID, _TreasureTable);

PROC
LeaderLib_Treasure_Internal_IncreaseTreasureTableCount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
DB_LeaderLib_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _Count)
AND
IntegerSum(_Count, 1, _NextCount)
THEN
NOT DB_LeaderLib_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _Count);
DB_LeaderLib_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _NextCount);

PROC
LeaderLib_Treasure_Internal_IncreaseTreasureTableCount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT DB_LeaderLib_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _)
THEN
DB_LeaderLib_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, 1);

/*Older saves*/
IF
StoryEvent(_, "LeaderLib_Initialized")
AND
DB_LeaderLib_Treasure_TableWasGenerated((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
NOT DB_LeaderLib_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, _)
THEN
DB_LeaderLib_Treasure_GeneratedTreasureTableCount(_Object, _TreasureID, _TreasureTable, 1);

QRY
LeaderLib_Treasure_QRY_TreasureTableUsesTemplates((STRING)_TreasureID, (STRING)_TreasureTable)
AND
DB_LeaderLib_Treasure_TreasureTableItemEntryMode(_TreasureID, _TreasureTable, 1)
THEN
DB_NOOP(1);
//END_REGION

//REGION INDIVIDUAL_TREASURE_GENERATION_QUEUE

PROC
LeaderLib_Treasure_Internal_CreateTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
NOT DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _)
AND
Random(999999, _Ran)
AND
IntegertoString(_Ran, _RanStr)
AND
StringConcatenate(_ID, "_TreasureQueue_", _a)
AND
StringConcatenate(_a, _RanStr, _TreasureQueueID)
THEN
DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID);

PROC
LeaderLib_Treasure_Internal_AddItemEntryToTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (STRING)_GenerationType, (INTEGER)_IsStat)
AND
NOT DB_LeaderLib_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
AND
DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
THEN
LeaderLib_Array_AddToArray(_TreasureQueueID, _ItemEntry);
DB_LeaderLib_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat);

PROC
LeaderLib_Treasure_Internal_StartTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
AND
NOT LeaderLib_Array_QRY_EmptyLength(_TreasureQueueID)
AND
NOT DB_LeaderLib_Treasure_GenerationSpeed(_TreasureID, _)
AND
DB_LeaderLib_Settings_QueueRates("ItemGeneration", _TickRate, _TimeoutRate)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartTreasureQueue] Starting treasure queue with a set _TickRate and _TimeoutRate for treasure [",_TreasureID,"].");
LeaderLib_Treasure_Internal_StartTreasureQueueWithRates(_ID, _TreasureQueueID, _TickRate, _TimeoutRate);

PROC
LeaderLib_Treasure_Internal_StartTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
AND
NOT LeaderLib_Array_QRY_EmptyLength(_TreasureQueueID)
AND
DB_LeaderLib_Treasure_GenerationSpeed(_TreasureID, _TickRate)
AND
DB_LeaderLib_Settings_QueueRates("ItemGeneration", _, _TimeoutRate)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartTreasureQueue] Starting treasure queue with a set _TimeoutRate for treasure [",_TreasureID,"].");
LeaderLib_Treasure_Internal_StartTreasureQueueWithRates(_ID, _TreasureQueueID, _TickRate, _TimeoutRate);

PROC
LeaderLib_Treasure_Internal_StartTreasureQueueWithRates((STRING)_ID, (STRING)_TreasureQueueID, (INTEGER)_TickRate, (INTEGER)_TimeoutRate)
//AND
//_TickRate > 0
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartTreasureQueueWithRates] Starting treasure queue [",_TreasureQueueID,"].");
LeaderLib_Queue_Create(_TreasureQueueID, _TreasureQueueID, "LeaderLib_Timers_Treasure_TreasureQueue", _TickRate, "LeaderLib_Internal_ProcessItemEntry", "LeaderLib_Internal_OnItemEntryFinished", "LeaderLib_Events_OnTreasureQueueComplete");
LeaderLib_Queue_SetTimeout(_TreasureQueueID, "LeaderLib_Timers_Treasure_ItemQueueTimeout", _TimeoutRate, "LeaderLib_Events_OnItemGenerationTimeout");
LeaderLib_Queue_Start(_TreasureQueueID);

PROC
LeaderLib_Treasure_Internal_StartTreasureQueue((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
AND
LeaderLib_Array_QRY_EmptyLength(_TreasureQueueID)
THEN
NOT DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartTreasureQueue] Treasure queue [",_ID,"][",_TreasureID,"][",_GenerationType,"] is empty. Skipping.");
LeaderLib_SendEvent("LeaderLib_Events_OnTreasureQueueComplete");

IF
StoryEvent(_, "LeaderLib_Internal_ProcessItemEntry")
AND
DB_LeaderLib_Queue_Temp_CurrentEntry(_QueueID, _ItemEntry)
AND
DB_LeaderLib_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat)
THEN
NOT DB_LeaderLib_Treasure_Temp_TreasureQueue_Entries(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat);
LeaderLib_Treasure_Internal_ProcessItemEntry(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, _IsStat);

IF
StoryEvent(_, "LeaderLib_Events_OnTreasureQueueComplete")
AND
DB_LeaderLib_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID)
AND
DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID)
THEN
LeaderLib_Queue_Stop(_TreasureQueueID);
LeaderLib_Queue_ClearQueue(_TreasureQueueID);
NOT DB_LeaderLib_Treasure_Temp_TreasureQueue_Settings(_ID, _TreasureQueueID);

IF
StoryEvent(_, "LeaderLib_Events_OnTreasureQueueComplete")
AND
DB_LeaderLib_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:OnTreasureQueueComplete] Treasure queue [",_TreasureID,"] complete.");
LeaderLib_Treasure_Internal_MarkTreasureAsFinished(_ID, _Object, _TreasureID);
//END_REGION

//REGION TREASURE_FINISHED_FAILED
PROC
LeaderLib_Treasure_Internal_MarkTreasureAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LeaderLib_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID)
THEN
NOT DB_LeaderLib_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID);

PROC
LeaderLib_Treasure_Internal_MarkTreasureAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
NOT LeaderLib_Treasure_QRY_StillInQueue(_Object)
AND
NOT LeaderLib_Treasure_QRY_StillGenerating(_ID, _Object, _TreasureID)
THEN
LeaderLib_Treasure_ResetDummyByID(_ID);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:MarkAsFinished] Generation finished for [",_ID,"]. Setting 'LeaderLib_Treasure_GenerationSuccessful' flag to true.");
ObjectSetFlag(_Object, "LeaderLib_Treasure_GenerationSuccessful", 0);

PROC
LeaderLib_Treasure_Internal_MarkTreasureAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
NOT LeaderLib_Treasure_QRY_StillGenerating(_ID, _Object, _TreasureID)
AND
ObjectIsCharacter(_Object, 1)
THEN
LeaderLib_Treasure_Internal_RemoveFromJustRegistered((CHARACTERGUID)_Object, _TreasureID);

PROC
LeaderLib_Treasure_Internal_MarkTreasureAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
NOT LeaderLib_Treasure_QRY_StillGenerating(_ID, _Object, _TreasureID)
THEN
LeaderLib_Treasure_Internal_OnGenerationFinished(_ID, _Object, _TreasureID);

PROC
LeaderLib_Treasure_Internal_MarkItemAsFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
THEN
LeaderLib_Treasure_SendGeneratedEvent(_Object, _TreasureID, _ItemEntry);
LeaderLib_Treasure_RemoveIfOnlyOnce(_Object, _TreasureID, _ItemEntry);
LeaderLib_SendEvent("LeaderLib_Internal_OnItemEntryFinished");

PROC
LeaderLib_Treasure_Internal_OnItemGenerationFailed((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
THEN
LeaderLib_SendEvent("LeaderLib_Events_OnItemGenerationTimeout");
//END_REGION

//REGION GENERATE_ITEMS
PROC
LeaderLib_Treasure_GenerateItems((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _ItemEntry, _RequirementID, _GenerationType)
THEN
LeaderLib_Treasure_Internal_AddItemEntryToTreasureQueue(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, 0);

PROC
LeaderLib_Treasure_GenerateItems((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
DB_LeaderLib_Treasure_TreasureItemStats(_TreasureID, _ItemEntry, _Amount, _RequirementID)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _ItemEntry, _RequirementID, _GenerationType)
THEN
LeaderLib_Treasure_Internal_AddItemEntryToTreasureQueue(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _GenerationType, 1);

PROC
LeaderLib_Treasure_GenerateItems((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
NOT LeaderLib_Treasure_QRY_HasRegisteredItems(_TreasureID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:GenerateItems] Skipping generation for items with [",_ID,"]: No entries found for Treasure ID [",_TreasureID,"].");
LeaderLib_Treasure_Internal_OnGenerationFinished(_ID, _Object, _TreasureID);
//LeaderLib_Treasure_Internal_OnGenerationFailed(_ID, _Object, _TreasureID, _GenerationType);

PROC
LeaderLib_Treasure_Internal_ProcessItemEntry((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (STRING)_GenerationType, (INTEGER)_IsStat)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ProcessItemEntry] Processing item entry [",_ItemEntry,"] for treasure [",_TreasureID,"].");

PROC
LeaderLib_Treasure_Internal_ProcessItemEntry((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (STRING)_GenerationType, (INTEGER)_IsStat)
AND
LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _ItemEntry, _RequirementID, _GenerationType)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ProcessItemEntry] Starting generation for [",_ID,"][",_ItemEntry,"].");
LeaderLib_Treasure_Internal_StartItemGeneration(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID, _IsStat);

PROC
LeaderLib_Treasure_Internal_ProcessItemEntry((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (STRING)_GenerationType, (INTEGER)_IsStat)
AND
NOT LeaderLib_Treasure_QRY_ItemCanGenerate(_TreasureID, _ItemEntry, _RequirementID, _GenerationType)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ProcessItemEntry] Skipping generation for [",_ID,"]. Treasure [",_TreasureID,"] does not pass the requirements.");
LeaderLib_SendEvent("LeaderLib_Internal_OnItemEntryFinished");

PROC
LeaderLib_Treasure_Internal_StartItemGeneration((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, (INTEGER)_IsStat)
AND
LeaderLib_Treasure_QRY_SkipAmountCheck(_Object, _TreasureID, _ItemEntry)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartItemGeneration] Skipping amount check and generating item [",_TreasureID,"]:[",_ItemEntry,"].");
ObjectSetFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 0);
DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, 0, _Amount, _IsStat);

PROC
LeaderLib_Treasure_Internal_StartItemGeneration((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, 0)
AND
NOT LeaderLib_Treasure_QRY_SkipAmountCheck(_Object, _TreasureID, _ItemEntry)
AND
LeaderLib_Treasure_QRY_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartItemGeneration] Counting complete for item entry [",_TreasureID,"]:[",_ItemEntry,"].");
DB_LeaderLib_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _RequirementID);
LeaderLib_Treasure_Internal_CountingComplete(_ID, _Object, _TreasureID, _ItemEntry, 0);

PROC
LeaderLib_Treasure_Internal_StartItemGeneration((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, 1)
AND
NOT LeaderLib_Treasure_QRY_SkipAmountCheck(_Object, _TreasureID, _ItemEntry)
AND
NOT DB_LeaderLib_Treasure_StatToTemplate(_ItemEntry, _)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:StartItemGeneration] Object is missing stat-based [",_TreasureID,"]:[",_ItemEntry,"] item template. Skipping counting.");
ObjectSetFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 0);
DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, 0, _Amount, 1);

PROC
LeaderLib_Treasure_Internal_StartItemGeneration((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount, (STRING)_RequirementID, 1)
AND
NOT DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _, _, 1)
AND
NOT LeaderLib_Treasure_QRY_SkipAmountCheck(_Object, _TreasureID, _ItemEntry)
AND
DB_LeaderLib_Treasure_StatToTemplate(_ItemEntry, _ItemTemplate)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:StartItemGeneration] Starting stat-based object counting for [",_TreasureID,"]:[",_ItemEntry,"] with template [",_ItemTemplate,"].");
SetVarString(_Object, "LeaderLib_Internal_TreasureQueueID", _ID);
SetVarString(_Object, "LeaderLib_Internal_TreasureID", _TreasureID);
LeaderLib_Treasure_CountTemplateWithStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry);
DB_LeaderLib_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _Amount, _RequirementID);

IF
StoryEvent(_Object, "LeaderLib_Events_Treasure_Internal_StatCountingComplete")
AND
GetVarString(_Object, "LeaderLib_Internal_TreasureQueueID", _ID)
AND
DB_LeaderLib_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _Amount, _RequirementID)
AND
LeaderLib_Treasure_QRY_CountedItems(_Object, _TreasureID, _ItemEntry)
AND
IntegertoString(_Amount, _AmountStr)
THEN
SetVarString(_Object, "LeaderLib_Internal_TreasureQueueID", "");
SetVarString(_Object, "LeaderLib_Internal_TreasureID", "");
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:StartItemGeneration] Object counting complete. Treasure [",_TreasureID,"] | Stat [",_ItemEntry,"] | Amount [",_AmountStr,"]");
LeaderLib_Treasure_Internal_CountingComplete(_ID, _Object, _TreasureID, _ItemEntry, 1);

IF
DB_LeaderLib_Treasure_Temp_GenerateItem((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_CreatedAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
THEN
NOT DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _CreatedAmount, _MaxAmount, _IsStat);
LeaderLib_Treasure_Internal_GenerateItemNow(_ID, _Object, _TreasureID, _ItemEntry, _CreatedAmount, _MaxAmount, _IsStat);

PROC
LeaderLib_Treasure_Internal_GenerateItemNow((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_CreatedAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_IsStat <= 0
AND
_CreatedAmount < _MaxAmount
AND
IntegerSum(_CreatedAmount, 1, _NextAmount)
AND
IntegertoString(_NextAmount, _AmountStr)
AND
IntegertoString(_MaxAmount, _MaxAmountStr)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:GenerateItems] Generating item [",_TreasureID,"]:[",_ItemEntry,"] [",_AmountStr,"/",_MaxAmountStr,"].");

PROC
LeaderLib_Treasure_Internal_GenerateItemNow((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_CreatedAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_IsStat <= 0
AND
_CreatedAmount < _MaxAmount
AND
IntegerSum(_CreatedAmount, 1, _NextAmount)
AND
GetPosition(_Object, _x,_y,_z)
AND
CreateItemTemplateAtPosition(_ItemEntry, _x,_y,_z, _Item)
THEN
LeaderLib_Treasure_Internal_CheckPostGenBonuses(_Object, _Item, _TreasureID, _ItemEntry);
ItemToInventory(_Item, _Object, 1, 0, 1);
LeaderLib_Treasure_Internal_IncrementGeneratedItem(_ID, _Object, _TreasureID, _ItemEntry, _NextAmount, _MaxAmount, _IsStat);

PROC
LeaderLib_Treasure_Internal_IncrementGeneratedItem((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_NextAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_NextAmount < _MaxAmount
THEN
DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _NextAmount, _MaxAmount, _IsStat);

PROC
LeaderLib_Treasure_Internal_IncrementGeneratedItem((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_NextAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_NextAmount >= _MaxAmount
THEN
LeaderLib_Treasure_Internal_FinishIfMaxAmount(_Object, _TreasureID, _ItemEntry, _NextAmount);
LeaderLib_Treasure_Internal_MarkItemAsFinished(_ID, _Object, _TreasureID, _ItemEntry);

PROC
LeaderLib_Treasure_Internal_IncrementGeneratedItem((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_NextAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_NextAmount >= _MaxAmount
AND
DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _Max, _IsStat)
THEN
NOT DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _Amount, _Max, _IsStat);

PROC
LeaderLib_Treasure_Internal_GenerateItemNow((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_CreatedAmount, (INTEGER)_MaxAmount, (INTEGER)_IsStat)
AND
_IsStat > 0
AND
_CreatedAmount < _MaxAmount
AND
StringConcatenate("CreateByStat_", _ID, _ArrayPrefix)
AND
StringConcatenate("LeaderLib_Events_Treasure_OnStatItemsGenerated_", _ID, _CompletionEvent)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:GenerateItems] Generating stat item [",_TreasureID,"]:[",_ItemEntry,"] via [LeaderLib_Treasure_CreateItemByStat].");
LeaderLib_CreateByStat_CreateQueue(_Object, _ArrayPrefix, 5, 2500, _CompletionEvent);
DB_LeaderLib_Treasure_Temp_CreatingByStat(_ID, _Object, _TreasureID, _ItemEntry, _MaxAmount, _ArrayPrefix, _CompletionEvent);
LeaderLib_CreateByStat_AddToQueue(_Object, _ArrayPrefix, _ItemEntry, _MaxAmount, 1, 0);
LeaderLib_CreateByStat_Start(_Object, _ArrayPrefix);

IF
StoryEvent((ITEMGUID)_Item, "LeaderLib_Events_StatItemGenerated")
AND
GetVarFixedString(_Item, "LeaderLib_GeneratedItemStat", _ItemEntry)
AND
DB_LeaderLib_Treasure_Temp_CreatingByStat(_ID, _Object, _TreasureID, _ItemEntry, _MaxAmount, _ArrayPrefix, _CompletionEvent)
THEN
LeaderLib_Treasure_Internal_CheckPostGenBonuses(_Object, _Item, _TreasureID, _ItemEntry);

IF
StoryEvent(_Object, _CompletionEvent)
AND
DB_LeaderLib_Treasure_Temp_CreatingByStat(_ID, _Object, _TreasureID, _ItemEntry, _MaxAmount, _ArrayPrefix, _CompletionEvent)
THEN
NOT DB_LeaderLib_Treasure_Temp_CreatingByStat(_ID, _Object, _TreasureID, _ItemEntry, _MaxAmount, _ArrayPrefix, _CompletionEvent);
LeaderLib_Treasure_Internal_FinishIfMaxAmount(_Object, _TreasureID, _ItemEntry, _MaxAmount);
LeaderLib_Treasure_Internal_MarkItemAsFinished(_ID, _Object, _TreasureID, _ItemEntry);

PROC
LeaderLib_Treasure_Internal_FinishIfMaxAmount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount)
AND
NOT DB_LeaderLib_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
AND
DB_LeaderLib_Treasure_ItemMaxAmount(_TreasureID, _ItemEntry, _MaxAmount)
AND
_Amount >= _MaxAmount
AND
NOT LeaderLib_Treasure_QRY_CanKeepGenerating(_TreasureID, _ItemEntry)
AND
GetTemplate(_Object, _Template)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:LeaderLib_Treasure_Internal_FinishIfMaxAmount] [",_TreasureID,"]:[",_ItemEntry,"] reached the max item limit set, and is done generating on object [",_Template,"].");
DB_LeaderLib_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry);

PROC
LeaderLib_Treasure_Internal_FinishIfMaxAmount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Amount)
AND
NOT DB_LeaderLib_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
AND
NOT DB_LeaderLib_Treasure_ItemMaxAmount(_TreasureID, _ItemEntry, _)
AND
IsTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly", 0)
AND
NOT LeaderLib_Treasure_QRY_CanKeepGenerating(_TreasureID, _ItemEntry)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:LeaderLib_Treasure_Internal_FinishIfMaxAmount] [",_TreasureID,"]:[",_ItemEntry,"] has no max limit set, and the tag [LeaderLib_Treasure_GenerateEndlessly] is not set. Finialized generating ItemEntry on object.");
DB_LeaderLib_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry);

QRY
LeaderLib_Treasure_QRY_CanKeepGenerating((STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_KeepGeneratingTreasure(_TreasureID)
AND
NOT DB_LeaderLib_Treasure_KeepGeneratingItem(_TreasureID, _ItemEntry, 0)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_CanKeepGenerating((STRING)_TreasureID, (STRING)_ItemEntry)
AND
NOT DB_LeaderLib_Treasure_KeepGeneratingTreasure(_TreasureID)
AND
DB_LeaderLib_Treasure_KeepGeneratingItem(_TreasureID, _ItemEntry, 1)
THEN
DB_NOOP(1);
//END_REGION

//REGION GENERATION_QUEUE_QUERIES
QRY
LeaderLib_Treasure_QRY_StillInQueue((GUIDSTRING)_Object)
AND
DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_, _Object, _, _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_StillGenerating((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, _CreatedAmount, _MaxAmount, _IsStat)
THEN
DB_NOOP(1);
//END_REGION

//REGION GENERATION_QUEUE
PROC
LeaderLib_Treasure_AddToGenerationQueue((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
NOT DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_, _Object, _TreasureID, _)
AND
Random(999999, _Ran)
AND
IntegertoString(_Ran, _RanStr)
AND
GetUUID(_Object, _ObjectID)
AND
StringConcatenate(_ObjectID, _TreasureID, _Msg1)
AND
StringConcatenate(_Msg1, _GenerationType, _Msg2)
AND
StringConcatenate(_Msg2, _RanStr, _ID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:AddToGenerationQueue] Added [",_ID,"] to generation queue.");
LeaderLib_Array_AddToArray("LeaderLib_ItemGenerationQueue", _ID);
DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType);

PROC
LeaderLib_Treasure_StartQueue()
AND
NOT LeaderLib_Array_QRY_DataExists("LeaderLib_ItemGenerationQueue")
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartQueue] No entries found in the item generation queue. Skipping.");
LeaderLib_SendEvent("LeaderLib_Events_OnGenerationQueueComplete");

PROC
LeaderLib_Treasure_StartQueue()
AND
DB_LeaderLib_Array_Length("LeaderLib_ItemGenerationQueue", _Length)
AND
_Length > 1
AND
DB_LeaderLib_Settings_QueueRates("Treasure", _TickRate, _TimeoutRate)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartQueue] Starting item generation queue.");
LeaderLib_Queue_Create("LeaderLib_ItemGenerationQueue", "LeaderLib_ItemGenerationQueue", "LeaderLib_Timers_Treasure_ItemQueue", _TickRate, "LeaderLib_Internal_ProcessTreasureQueueEntry", "LeaderLib_Internal_OnTreasureQueueComplete", "LeaderLib_Events_OnGenerationQueueComplete");
LeaderLib_Queue_SetTimeout("LeaderLib_ItemGenerationQueue", "LeaderLib_Timers_Treasure_TreasureQueueTimeout", _TimeoutRate, "LeaderLib_Events_OnTreasureGenerationTimeout");
LeaderLib_Queue_Start("LeaderLib_ItemGenerationQueue");

PROC
LeaderLib_Treasure_StartQueue()
AND
DB_LeaderLib_Array_Length("LeaderLib_ItemGenerationQueue", _Length)
AND
_Length <= 1
AND
DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType)
AND
DB_LeaderLib_Array_Data("LeaderLib_ItemGenerationQueue", _Index, _ID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StartQueue] Single entry detected. Skipping queue and generating [",_ID,"] directly.");
LeaderLib_Treasure_Internal_ProcessQueueItem(_ID);
LeaderLib_Array_RemoveFromArray("LeaderLib_ItemGenerationQueue", _Index, _ID);
LeaderLib_SendEvent("LeaderLib_Events_OnGenerationQueueComplete");

PROC
LeaderLib_Treasure_Internal_ProcessQueueItem((STRING)_ID)
AND
DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType)
AND
LeaderLib_Treasure_QRY_TreasureHasItemsToGenerate(_TreasureID, _GenerationType)
THEN
DB_LeaderLib_Treasure_Temp_IsProcessingItem(_ID);
NOT DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ProcessQueueItem] Generating treasure for [",_ID,"].");
DB_LeaderLib_Treasure_Temp_CurrentTreasure(_ID, _Object, _TreasureID);
LeaderLib_Treasure_Internal_CreateTreasureQueue(_ID, _Object, _TreasureID, _GenerationType);
LeaderLib_Treasure_GenerateItems(_ID, _Object, _TreasureID, _GenerationType);
LeaderLib_Treasure_Internal_StartTreasureQueue(_ID, _Object, _TreasureID, _GenerationType);

//Nothing to generate
PROC
LeaderLib_Treasure_Internal_ProcessQueueItem((STRING)_ID)
AND
DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType)
AND
NOT DB_LeaderLib_Treasure_Temp_IsProcessingItem(_ID)
THEN
NOT DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ProcessQueueItem] No items to generate for treasure [",_ID,"][",_TreasureID,"][",_GenerationType,"]. Completing queue.");
LeaderLib_SendEvent("LeaderLib_Internal_OnTreasureQueueComplete");

PROC
LeaderLib_Treasure_Internal_ProcessQueueItem((STRING)_ID)
AND
DB_LeaderLib_Treasure_Temp_IsProcessingItem(_ID)
THEN
NOT DB_LeaderLib_Treasure_Temp_IsProcessingItem(_ID);

PROC
LeaderLib_Treasure_Internal_RemoveFromJustRegistered((CHARACTERGUID)_Trader, (STRING)_TreasureID)
AND
DB_LeaderLib_Traders_Active(_Trader, _TraderID, _Level)
AND
DB_LeaderLib_Traders_Temp_TreasureJustRegistered(_TreasureID, _TraderID)
THEN
NOT DB_LeaderLib_Traders_Temp_TreasureJustRegistered(_TreasureID, _TraderID);

PROC
LeaderLib_Treasure_Internal_OnGenerationFailed((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:OnGenerationFailed] Failed to generate items for [",_ID,"]. Going to next item in queue.");
SetStoryEvent(_Object, "LeaderLib_Events_ResetGeneratingFlag");
//END_REGION

//REGION GENERATION_QUEUE_MANUAL_MODE
//Manual starting
PROC
LeaderLib_Treasure_AddToGenerationQueue((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
NOT DB_LeaderLib_Treasure_Temp_ManualTimerRunning(_)
AND
NOT LeaderLib_Queue_QRY_IsRunning("LeaderLib_ItemGenerationQueue")
AND
DB_LeaderLib_Initialized(_)
AND
DB_LeaderLib_Array_Length("LeaderLib_ItemGenerationQueue", _Length)
AND
_Length > 0
AND
NOT DB_GlobalFlag("LeaderLib_DefaultEventFlowRunning")
AND
GlobalGetFlag("LeaderLib_InitialEventFlowComplete", _InitComplete)
THEN
LeaderLib_Treasure_Internal_StartManualTimer(_InitComplete);

PROC
LeaderLib_Treasure_AddToGenerationQueue((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_GenerationType)
AND
LeaderLib_Queue_QRY_IsRunning("LeaderLib_ItemGenerationQueue")
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:AddToGenerationQueue] [LeaderLib_ItemGenerationQueue] is already running.");

PROC
LeaderLib_Treasure_Internal_StartManualTimer(0)
AND
NOT DB_LeaderLib_Treasure_Temp_ManualTimerRunning(_)
THEN
DB_LeaderLib_Treasure_Temp_ManualTimerRunning(1);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:AddToGenerationQueue] Starting manual generation timer after 2.5 seconds.");
TimerCancel("LeaderLib_Timers_Treasure_ManualGenerationTimer");
TimerLaunch("LeaderLib_Timers_Treasure_ManualGenerationTimer", 2500);

PROC
LeaderLib_Treasure_Internal_StartManualTimer(1)
AND
NOT DB_LeaderLib_Treasure_Temp_ManualTimerRunning(_)
THEN
DB_LeaderLib_Treasure_Temp_ManualTimerRunning(1);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:AddToGenerationQueue] Starting manual generation timer after 250ms.");
TimerCancel("LeaderLib_Timers_Treasure_ManualGenerationTimer");
TimerLaunch("LeaderLib_Timers_Treasure_ManualGenerationTimer", 250);

IF
GlobalFlagSet("LeaderLib_DefaultEventFlowRunning")
AND
DB_LeaderLib_Treasure_Temp_ManualTimerRunning(_Var)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:LeaderLib_DefaultEventFlowRunning] Canceling manual generation timer.");
NOT DB_LeaderLib_Treasure_Temp_ManualTimerRunning(_Var);
TimerCancel("LeaderLib_Timers_Treasure_ManualGenerationTimer");

IF
TimerFinished("LeaderLib_Timers_Treasure_ManualGenerationTimer")
AND
DB_LeaderLib_Treasure_Temp_ManualTimerRunning(_Var)
THEN
NOT DB_LeaderLib_Treasure_Temp_ManualTimerRunning(_Var);

IF
TimerFinished("LeaderLib_Timers_Treasure_ManualGenerationTimer")
AND
LeaderLib_Queue_QRY_IsRunning("LeaderLib_ItemGenerationQueue")
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ManualGenerationTimer] Queue [LeaderLib_ItemGenerationQueue] is already running.");

IF
TimerFinished("LeaderLib_Timers_Treasure_ManualGenerationTimer")
AND
NOT LeaderLib_Queue_QRY_IsRunning("LeaderLib_ItemGenerationQueue")
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ManualGenerationTimer] Manually starting treasure generation.");
LeaderLib_SendEvent("LeaderLib_Commands_StartTreasureGeneration");

IF
StoryEvent(_, "LeaderLib_Events_OnGenerationQueueComplete")
AND
GlobalGetFlag("LeaderLib_DefaultEventFlowRunning", 0)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:OnTreasureQueueComplete] Treasure generation queue manually completed (outside of the event flow).");
//END_REGION

//REGION GENERATION_QUEUE_EVENTS
IF
StoryEvent(_, "LeaderLib_Commands_StartTreasureGeneration")
THEN
GlobalSetFlag("LeaderLib_EventFlow_TreasureGenerationActive");
LeaderLib_Treasure_StartQueue();

IF
StoryEvent(_, "LeaderLib_Internal_ProcessTreasureQueueEntry")
AND
DB_LeaderLib_Queue_Temp_CurrentEntry(_ArrayID, _ID)
THEN
LeaderLib_Treasure_Internal_ProcessQueueItem(_ID);

IF
StoryEvent(_, "LeaderLib_Events_OnTreasureGenerationTimeout")
AND
DB_LeaderLib_Queue_Temp_CurrentEntry(_ArrayID, _ID)
AND
DB_LeaderLib_Treasure_Temp_ItemGenerationQueue(_ID, _Object, _TreasureID, _GenerationType)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:GenerationQueueTimeout] [",_ID,"] timed out.");
LeaderLib_Treasure_Internal_OnGenerationFailed(_ID, _Object, _TreasureID, _GenerationType);

PROC
LeaderLib_Treasure_Internal_OnGenerationFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:Internal:OnGenerationFinished] [",_ID,"] Object finished generating treasure [",_TreasureID,"].");
LeaderLib_Treasure_Internal_ApplyPostGenerationBonuses(_Object, _TreasureID);
LeaderLib_SendEvent("LeaderLib_Internal_OnTreasureQueueComplete");

IF
StoryEvent(_, "LeaderLib_Events_OnGenerationQueueComplete")
THEN
GlobalClearFlag("LeaderLib_EventFlow_TreasureGenerationActive");
LeaderLib_Queue_Stop("LeaderLib_ItemGenerationQueue");
LeaderLib_Queue_ClearQueue("LeaderLib_ItemGenerationQueue");
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:OnGenerationFinished] Item generation queue complete. Stopped and cleared queue [LeaderLib_ItemGenerationQueue].");
LeaderLib_SendEvent("LeaderLib_Events_OnTreasureGenerationComplete");
//END_REGION

//REGION STOP_QUEUE
IF
DB_LeaderLib_EventFlow_StopEvent("LeaderLib_Commands_StartTreasureGeneration")
THEN
LeaderLib_Treasure_Internal_StopQueue();
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StopQueue] Item generation queue forcefully stopped.");
NOT DB_LeaderLib_EventFlow_StopEvent("LeaderLib_Commands_StartTreasureGeneration");

PROC
LeaderLib_Treasure_Internal_StopQueue()
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:StopQueue] Cleared generation queue.");
LeaderLib_Queue_Stop("LeaderLib_ItemGenerationQueue");
LeaderLib_Queue_ClearQueue("LeaderLib_ItemGenerationQueue");
//SysClear("DB_LeaderLib_Treasure_Temp_ItemGenerationQueue", 4);
//END_REGION

//REGION ON_GENERATION_FINISHED
PROC
LeaderLib_Treasure_Internal_OnGenerationFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
NOT ObjectGetFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 1)
THEN
ObjectClearFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 0);

PROC
LeaderLib_Treasure_Internal_OnGenerationFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
NOT ObjectGetFlag(_Object, "LeaderLib_Treasure_JustGeneratedTreasure", 1)
THEN
ObjectSetFlag(_Object, "LeaderLib_Treasure_JustGeneratedTreasure", 0);

PROC
LeaderLib_Treasure_Internal_OnGenerationFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
ObjectGetFlag(_Object, "LeaderLib_Treasure_JustGeneratedTreasure", 1)
AND
LeaderLib_Timers_QRY_ObjectTimerStarted(_Object, "LeaderLib_Timers_Treasure_ResetGeneratingFlag_", "LeaderLib_Events_ResetGeneratingFlag")
THEN
LeaderLib_Timers_RestartObjectTimer(_Object, "LeaderLib_Timers_Treasure_ResetGeneratingFlag_", 750);

PROC
LeaderLib_Treasure_Internal_OnGenerationFinished((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID)
AND
ObjectGetFlag(_Object, "LeaderLib_Treasure_JustGeneratedTreasure", 1)
AND
NOT LeaderLib_Timers_QRY_ObjectTimerStarted(_Object, "LeaderLib_Timers_Treasure_ResetGeneratingFlag_", "LeaderLib_Events_ResetGeneratingFlag")
THEN
LeaderLib_Timers_StartObjectTimer(_Object, 750, "LeaderLib_Timers_Treasure_ResetGeneratingFlag_", "LeaderLib_Events_ResetGeneratingFlag");

IF
StoryEvent(_Object, "LeaderLib_Events_ResetGeneratingFlag")
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ResetGeneratedFlagTimer] Clearing flags [LeaderLib_Treasure_JustGeneratedTreasure] and [LeaderLib_Treasure_IsGeneratingTreasure]. Sending event [LeaderLib_Events_OnGenerationComplete] on object.");
ObjectClearFlag(_Object, "LeaderLib_Treasure_JustGeneratedTreasure", 0);
ObjectClearFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 0);
SetStoryEvent(_Object, "LeaderLib_Events_OnGenerationComplete");

IF
StoryEvent(_Object, "LeaderLib_Events_ResetGeneratingFlag")
AND
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
NOT DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);
//END_REGION

//REGION COUNTING_COMPLETE
PROC
LeaderLib_Treasure_Internal_CountingComplete((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 0)
AND
DB_LeaderLib_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID)
AND
DB_LeaderLib_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemEntry, _CurrentAmount)
AND
LeaderLib_Treasure_QRY_ItemLimitNotMet(_Object, _TreasureID, _ItemEntry, _GeneratedAmount, _CurrentAmount)
AND
DB_LeaderLib_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:CountingComplete] Counting complete. Generating item by template for [",_TreasureID,"]:[",_ItemEntry,"].");
ObjectSetFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 0);
DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, 0, _AmountToCreate, 0);
NOT DB_LeaderLib_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate);
NOT DB_LeaderLib_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemEntry, _CurrentAmount);
NOT DB_LeaderLib_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID);

QRY
LeaderLib_Treasure_Internal_QRY_SkipGeneration((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Type)
AND
NOT DB_LeaderLib_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_SkipGeneration((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_Type)
AND
DB_LeaderLib_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate)
AND
_AmountToCreate <= 0
THEN
NOT DB_LeaderLib_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate);

QRY
LeaderLib_Treasure_Internal_QRY_SkipGeneration((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 0)
AND
NOT DB_LeaderLib_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemEntry, _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_SkipGeneration((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 1)
AND
NOT DB_LeaderLib_Treasure_Temp_ItemStatAmount(_Object, _TreasureID, _, _ItemEntry, _)
THEN
DB_NOOP(1);

PROC
LeaderLib_Treasure_Internal_ClearItemEntryAmount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_ItemTemplate)
AND
DB_LeaderLib_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemEntry, _CurrentAmount)
THEN
NOT DB_LeaderLib_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemEntry, _CurrentAmount);

PROC
LeaderLib_Treasure_Internal_ClearItemEntryAmount((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_ItemTemplate)
AND
DB_LeaderLib_Treasure_Temp_ItemStatAmount(_Object, _TreasureID, _ItemTemplate, _ItemEntry, _CurrentAmount)
THEN
NOT DB_LeaderLib_Treasure_Temp_ItemStatAmount(_Object, _TreasureID, _ItemTemplate, _ItemEntry, _CurrentAmount);

PROC
LeaderLib_Treasure_Internal_CountingComplete((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 0)
AND
DB_LeaderLib_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID)
AND
LeaderLib_Treasure_Internal_QRY_SkipGeneration(_Object, _TreasureID, _ItemEntry, 0)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:CountingComplete] Item limit met for [",_TreasureID,"]:[",_ItemEntry,"]. Marking as finished.");
NOT DB_LeaderLib_Treasure_Temp_Queue_CountTemplate(_ID, _Object, _TreasureID, _ItemEntry, _GeneratedAmount, _RequirementID);
LeaderLib_Treasure_Internal_ClearItemEntryAmount(_Object, _TreasureID, _ItemEntry, "");
LeaderLib_Treasure_Internal_MarkItemAsFinished(_ID, _Object, _TreasureID, _ItemEntry);

PROC
LeaderLib_Treasure_Internal_CountingComplete((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 1)
AND
DB_LeaderLib_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID)
AND
//DB_LeaderLib_Treasure_Temp_ItemTemplateAmount(_Object, _TreasureID, _ItemTemplate, _CurrentAmount)
DB_LeaderLib_Treasure_Temp_ItemStatAmount(_Object, _TreasureID, _ItemTemplate, _ItemEntry, _CurrentAmount)
AND
LeaderLib_Treasure_QRY_ItemLimitNotMet(_Object, _TreasureID, _ItemEntry, _GeneratedAmount, _CurrentAmount)
AND
DB_LeaderLib_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate)
AND
IntegertoString(_AmountToCreate, _NextAmountStr)
AND
IntegertoString(_GeneratedAmount, _GenAmountStr)
AND
IntegertoString(_CurrentAmount, _CurrAmountStr)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:CountingComplete] Counting complete. Generating [",_NextAmountStr,"] (Current: [",_CurrAmountStr,"] Desired: [",_GenAmountStr,"]) item(s) by stat [",_ItemEntry,"].");
ObjectSetFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 0);
DB_LeaderLib_Treasure_Temp_GenerateItem(_ID, _Object, _TreasureID, _ItemEntry, 0, _AmountToCreate, 1);
NOT DB_LeaderLib_Treasure_Temp_AmountToCreate(_Object, _ItemEntry, _AmountToCreate);
NOT DB_LeaderLib_Treasure_Temp_ItemStatAmount(_Object, _TreasureID, _ItemTemplate, _ItemEntry, _CurrentAmount);
NOT DB_LeaderLib_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID);

PROC
LeaderLib_Treasure_Internal_CountingComplete((STRING)_ID, (GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, 1)
AND
DB_LeaderLib_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID)
AND
LeaderLib_Treasure_Internal_QRY_SkipGeneration(_Object, _TreasureID, _ItemEntry, 1)
THEN
NOT DB_LeaderLib_Treasure_Temp_Queue_CountStat(_ID, _Object, _TreasureID, _ItemTemplate, _ItemEntry, _GeneratedAmount, _RequirementID);
LeaderLib_Treasure_Internal_ClearItemEntryAmount(_Object, _TreasureID, _ItemEntry, _ItemTemplate);
LeaderLib_Treasure_Internal_MarkItemAsFinished(_ID, _Object, _TreasureID, _ItemEntry);
//END_REGION

//REGION POST_GENERATION
PROC
LeaderLib_Treasure_SendGeneratedEvent((GUIDSTRING)_Owner, (STRING)_OwnerID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_GeneratedEvent(_OwnerID, _ItemEntry, _OnGeneratedEvent)
THEN
SetStoryEvent(_Owner, _OnGeneratedEvent);

PROC
LeaderLib_Treasure_RemoveIfOnlyOnce((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_OnlyOnce(_TreasureID, _ItemEntry, _OnCompletionEvent)
AND
DB_LeaderLib_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID)
THEN
NOT DB_LeaderLib_Treasure_TreasureItemTemplates(_TreasureID, _ItemEntry, _Amount, _RequirementID);

PROC
LeaderLib_Treasure_RemoveIfOnlyOnce((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_TreasureTable)
AND
DB_LeaderLib_Treasure_OnlyOnce(_TreasureID, _TreasureTable, _OnCompletionEvent)
AND
DB_LeaderLib_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel)
THEN
NOT DB_LeaderLib_Treasure_RegisteredTreasureTable(_TreasureID, _TreasureTable, _RequirementID, _UsePartyLevel, _MinLevel, _MaxLevel);

PROC
LeaderLib_Treasure_RemoveIfOnlyOnce((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_OnlyOnce(_TreasureID, _ItemEntry, _OnCompletionEvent)
AND
_OnCompletionEvent != ""
THEN
SetStoryEvent(_Object, _OnCompletionEvent);

PROC
LeaderLib_Treasure_RemoveIfOnlyOnce((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_OnlyOnce(_TreasureID, _ItemEntry, _OnCompletionEvent)
THEN
NOT DB_LeaderLib_Treasure_OnlyOnce(_TreasureID, _ItemEntry, _OnCompletionEvent);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:RemoveIfOnlyOnce] Removed entry data for [",_TreasureID,":",_ItemEntry,"] with Completion Event [",_OnCompletionEvent,"].");

PROC
LeaderLib_Treasure_DisableGenerationForObject((GUIDSTRING)_Object)
AND
IsTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly", 0)
THEN
ObjectSetFlag(_Object, "LeaderLib_Treasure_GenerationEnded", 0);

IF
ObjectWasTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly")
AND
ObjectGetFlag(_Object, "LeaderLib_Treasure_GenerationEnded", 1)
THEN
ObjectClearFlag(_Object, "LeaderLib_Treasure_GenerationEnded", 0);

QRY
LeaderLib_Treasure_Internal_QRY_HasPostGenerationApplyBonuses((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
DB_LeaderLib_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry)
THEN
DB_NOOP(1);

PROC
LeaderLib_Treasure_Internal_ApplyPostGenerationBonuses((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
LeaderLib_Treasure_Internal_QRY_HasPostGenerationApplyBonuses(_Object, _TreasureID)
AND
LeaderLib_Timers_QRY_ObjectTimerStarted(_Object, "LeaderLib_Timers_Treasure_ApplyBonusesTimer_")
THEN
LeaderLib_Timers_RestartObjectTimer(_Object, "LeaderLib_Timers_Treasure_ApplyBonusesTimer_", 25);

PROC
LeaderLib_Treasure_Internal_ApplyPostGenerationBonuses((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
LeaderLib_Treasure_Internal_QRY_HasPostGenerationApplyBonuses(_Object, _TreasureID)
AND
NOT LeaderLib_Timers_QRY_ObjectTimerStarted(_Object, "LeaderLib_Timers_Treasure_ApplyBonusesTimer_")
THEN
LeaderLib_Timers_StartObjectTimer(_Object, 25, "LeaderLib_Timers_Treasure_ApplyBonusesTimer_", "LeaderLib_Events_Internal_ApplyPostGenBonuses");

IF
StoryEvent(_Object, "LeaderLib_Events_Internal_ApplyPostGenBonuses")
AND
DB_LeaderLib_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry)
THEN
NOT DB_LeaderLib_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:Internal:ApplyPostGenerationBonuses] Applying postgen bonuses for ItemEntry [",_ItemEntry,"] with _TreasureID [",_TreasureID,"]. ");
LeaderLib_Treasure_AdjustItemLevel(_Item, _TreasureID, _ItemEntry);
LeaderLib_Treasure_ApplyDeltaMods(_Item, _TreasureID, _ItemEntry);
LeaderLib_Treasure_InsertRunes(_Item, _TreasureID, _ItemEntry);
//END_REGION

//REGION ITEM_POSTGEN_MODIFIERS
PROC
LeaderLib_Treasure_Internal_CheckPostGenBonuses((GUIDSTRING)_Object, (ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
LeaderLib_Treasure_QRY_HasPostGenerationBonuses(_TreasureID, _ItemEntry)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:CheckPostGenBonuses] Item [",_ItemEntry,"] generated from treasure [",_TreasureID,"] has post-gen bonuses.");
DB_LeaderLib_Treasure_Temp_ApplyBonuses(_Object, _Item, _TreasureID, _ItemEntry);

QRY
LeaderLib_Treasure_QRY_HasPostGenerationBonuses((STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_ItemLevel(_TreasureID, _ItemEntry, _UsePartyLevel, _MinLevel, _MaxLevel)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_HasPostGenerationBonuses((STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_ItemDeltaMods(_ID, _TreasureID, _ItemEntry, _Deltamod, _Chance)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_HasPostGenerationBonuses((STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_ItemRunes(_ID, _TreasureID, _ItemEntry, _Rune, _Chance)
THEN
DB_NOOP(1);

PROC
LeaderLib_Treasure_AdjustItemLevel((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_ItemLevel(_TreasureID, _ItemEntry, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
_UsePartyLevel > 0
AND
LeaderLib_Helper_QRY_GetHighestPlayerLevel()
AND
DB_LeaderLib_Helper_Temp_HighestPlayerLevel(_Level)
THEN
ItemLevelUpTo(_Item, _Level);
NOT DB_LeaderLib_Helper_Temp_HighestPlayerLevel(_Level);

PROC
LeaderLib_Treasure_AdjustItemLevel((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_ItemLevel(_TreasureID, _ItemEntry, _UsePartyLevel, _MinLevel, _MaxLevel)
AND
_UsePartyLevel <= 0
AND
LeaderLib_Random_QRY(_MinLevel, _MaxLevel)
AND
DB_LeaderLib_Random(_Level)
THEN
ItemLevelUpTo(_Item, _Level);
NOT DB_LeaderLib_Random(_Level);

QRY
LeaderLib_Treasure_QRY_Internal_RollSucceeded((INTEGER)_Chance)
AND
_Chance <= -1
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_Internal_RollSucceeded((INTEGER)_Chance)
AND
_Chance >= 100
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_Internal_RollSucceeded((INTEGER)_Chance)
AND
_Chance > 0
AND
_Chance < 100
AND
IntegerProduct(_Chance, 100, _Target) // Ranged out of 999 are more random than 100 max
AND
LeaderLib_Roll_QRY(_Target)
AND
DB_LeaderLib_Random(_Roll)
AND
LeaderLog_QRY_LogInt("TRACE", "[LeaderLib:TreasureSystem:Internal:RollSucceeded] Rolled: [",_Roll,"/",_Target,"].")
THEN
NOT DB_LeaderLib_Random(_Roll);

QRY
LeaderLib_Treasure_QRY_Internal_CanApplyDeltamod((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_Deltamod)
AND
NOT ItemHasDeltaModifier(_Item, _Deltamod, _)
THEN
DB_NOOP(1);

//If a max is set, allow more than one count of a deltamod
QRY
LeaderLib_Treasure_QRY_Internal_CanApplyDeltamod((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry, (STRING)_Deltamod)
AND
ItemHasDeltaModifier(_Item, _Deltamod, _Count)
AND
DB_LeaderLib_Treasure_DeltaModLimit(_TreasureID, _ItemEntry, _Deltamod, _Max)
AND
_Count < _Max
THEN
DB_NOOP(1);

PROC
LeaderLib_Treasure_ApplyDeltaMods((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_ItemDeltaMods(_ID, _TreasureID, _ItemEntry, _Deltamod, _Chance)
AND
LeaderLib_Treasure_QRY_Internal_CanApplyDeltamod(_Item, _TreasureID, _ItemEntry, _Deltamod)
AND
LeaderLib_Treasure_QRY_Internal_RollSucceeded(_Chance)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:ApplyDeltaMods] Added deltamod [",_Deltamod,"] to [",_TreasureID,"][",_ItemEntry,"].");
ItemAddDeltaModifier(_Item, _Deltamod);

PROC
LeaderLib_Treasure_InsertRunes((ITEMGUID)_Item, (STRING)_TreasureID, (STRING)_ItemEntry)
AND
DB_LeaderLib_Treasure_ItemRunes(_ID, _TreasureID, _ItemEntry, _Rune, _Chance)
THEN
LeaderLib_Treasure_Internal_TryInsertRune(_Item, _Rune, _Chance);

PROC
LeaderLib_Treasure_Internal_TryInsertRune((ITEMGUID)_Item, (STRING)_Rune, (INTEGER)_Chance)
AND
LeaderLib_Treasure_QRY_Internal_RollSucceeded(_Chance)
AND
NOT LeaderLib_Treasure_QRY_InsertRuneInSlot(_Item, _Rune, 0)
AND
NOT LeaderLib_Treasure_QRY_InsertRuneInSlot(_Item, _Rune, 1)
AND
NOT LeaderLib_Treasure_QRY_InsertRuneInSlot(_Item, _Rune, 2)
AND
IntegertoString(_Chance, _ChanceStr)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:Internal:TryInsertRune] Failed to insert rune [",_Rune,"] into item. Chance [",_ChanceStr,"%].");

PROC
LeaderLib_Treasure_Internal_TryInsertRune((ITEMGUID)_Item, (STRING)_Rune, (INTEGER)_Chance)
AND
DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
THEN
NOT DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item);

QRY
LeaderLib_Treasure_QRY_InsertRuneInSlot((ITEMGUID)_Item, (STRING)_Rune, (INTEGER)_Slot)
AND
NOT ItemGetRuneItemTemplate(_Item, _Slot, _)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot) //Prevents crashes from adding runes into non-existent slots
THEN
ItemInsertRune(NULL_00000000-0000-0000-0000-000000000000, _Item, _Rune, _Slot);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot)
AND
NOT DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
GetTemplate(_Item, _Template)
AND
StringContains(_Template, "Amulet", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_Armor_Amulet_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_Armor_Amulet_EmptyRuneSlot", _)
THEN
DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot)
AND
NOT DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
GetTemplate(_Item, _Template)
AND
StringContains(_Template, "WPN", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_Weapon_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_Weapon_EmptyRuneSlot", _)
THEN
DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot)
AND
NOT DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
GetTemplate(_Item, _Template)
AND
StringContains(_Template, "EQ_", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor(_Item, _Slot, _Template)
THEN
DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_Template)
AND
NOT DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
StringContains(_Template, "Upperbody", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_Armor_UpperBody_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_Armor_UpperBody_EmptyRuneSlot", _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_Template)
AND
NOT DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
StringContains(_Template, "Lowerbody", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_LeaderLib_Armor_LowerBody_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_LeaderLib_Armor_LowerBody_EmptyRuneSlot", _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_Template)
AND
NOT DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
StringContains(_Template, "Legs", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_LeaderLib_Armor_Boots_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_LeaderLib_Armor_Boots_EmptyRuneSlot", _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlotsToArmor((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_Template)
AND
NOT DB_LeaderLib_Treasure_Temp_AddedRuneSlotDeltaMod(_Item)
AND
StringContains(_Template, "Arms", 1)
AND
LeaderLib_Treasure_Internal_QRY_AddRuneSlots(_Item, _Slot, "Boost_LeaderLib_Armor_Arms_EmptyRuneSlot")
AND
ItemHasDeltaModifier(_Item, "Boost_LeaderLib_Armor_Arms_EmptyRuneSlot", _)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_RuneSlotDeltaMod)
AND
ItemHasDeltaModifier(_Item, _RuneSlotDeltaMod, _Count)
AND
IntegerSubtract(_Count, 1, _Slots)
AND
_Slots < _Slot
THEN
ItemAddDeltaModifier(_Item, _RuneSlotDeltaMod);

QRY
LeaderLib_Treasure_Internal_QRY_AddRuneSlots((ITEMGUID)_Item, (INTEGER)_Slot, (STRING)_RuneSlotDeltaMod)
AND
NOT ItemHasDeltaModifier(_Item, _RuneSlotDeltaMod, _)
THEN
ItemAddDeltaModifier(_Item, _RuneSlotDeltaMod);
//END_REGION

//REGION GENERATION_EVENTS
QRY
LeaderLib_Treasure_QRY_ObjectCanStartGeneration((GUIDSTRING)_Object)
AND
NOT ObjectGetFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 1)
AND
NOT ObjectGetFlag(_Object, "LeaderLib_Treasure_GenerationEnded", 1)
THEN
DB_NOOP(1);

QRY
LeaderLib_Treasure_QRY_ObjectCanStartGeneration((GUIDSTRING)_Object)
AND
NOT ObjectGetFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 1)
AND
IsTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly", 1)
THEN
DB_NOOP(1);

PROC
LeaderLib_Treasure_GenerateOnNewlyRegistered((GUIDSTRING)_Object, (STRING)_TreasureID)
AND
ObjectGetFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 0)
AND
LeaderLib_Treasure_QRY_TreasureHasGenerationType(_TreasureID, "REGISTERED")
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:GenerateOnNewlyRegistered] Generating items for treasure with ID [",_TreasureID,"]");
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "REGISTERED");

IF
ObjectFlagSet("LeaderLib_Treasure_GenerateNow", _Object, _)
AND
LeaderLib_Helper_QRY_ClearObjectFlag(_Object, "LeaderLib_Treasure_GenerateNow")
AND
ObjectGetFlag(_Object, "LeaderLib_Treasure_IsGeneratingTreasure", 0)
AND
LeaderLib_Treasure_QRY_GetTreasureID(_Object)
AND
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem:GenerateNow] Manually generating items for treasure with ID [",_TreasureID,"]");
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "MANUAL");
NOT DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

QRY
LeaderLib_Trader_QRY_DefaultTradeGenerationIgnored((CHARACTERGUID)_Trader)
AND
IsTagged(_Trader, "LeaderLib_Trader_IgnoreTradeGeneration", 1)
THEN
DB_NOOP(1);

//Disable trade generation events if some other type is registered
QRY
LeaderLib_Trader_QRY_DefaultTradeGenerationIgnored((CHARACTERGUID)_Trader)
AND
DB_LeaderLib_Traders_Active(_Trader, _TraderID, _Level)
AND
DB_LeaderLib_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
AND
NOT DB_LeaderLib_Treasure_TreasureGenerationType(_TreasureID, "TRADE_GENERATION_END")
AND
DB_LeaderLib_Treasure_TreasureGenerationType(_TreasureID, _GenerationType)
AND
_GenerationType != "TRADE_GENERATION_END"
THEN
DB_NOOP(1);

IF
TradeGenerationEnded(_Trader)
AND
DB_LeaderLib_Traders_Active(_Trader, _TraderID, _Level)
AND
LeaderLib_Treasure_QRY_ObjectCanStartGeneration((GUIDSTRING)_Trader)
AND
NOT LeaderLib_Trader_QRY_DefaultTradeGenerationIgnored((CHARACTERGUID)_Trader)
AND
DB_LeaderLib_Treasure_RegisteredTraderTreasure(_TreasureID, _TraderID)
//AND
//Skip this check since it's the default generation type for traders
//LeaderLib_Treasure_QRY_TreasureHasGenerationType(_TreasureID, "TRADE_GENERATION_END")
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Trader, _TreasureID, "TRADE_GENERATION_END");
NOT DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Trader, _TreasureID);

//When an object is found by its registered treasure ID and template
IF
StoryEvent(_, "LeaderLib_Events_Treasure_ContinueGeneration")
AND
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
AND
DB_LeaderLib_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType)
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, _GenerationType);
NOT DB_LeaderLib_Treasure_Temp_MatchTemplate(_TreasureID, _Template, _GenerationType);
NOT DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);

//To prevent multiple generation events when more than one player levels up at the same time
PROC
LeaderLib_Treasure_AddToGenerationQueue((GUIDSTRING)_Object, (STRING)_TreasureID, "PARTY_LEVELED_UP")
AND
NOT DB_LeaderLib_Treasure_Temp_PartyLeveledUpGenerationTimer(_, _TreasureID)
AND
StringConcatenate("LeaderLib_Timers_Treasure_PartyLeveledUpGenerationBlocker_", _TreasureID, _TimerName)
THEN
DB_LeaderLib_Treasure_Temp_PartyLeveledUpGenerationTimer(_TimerName, _TreasureID);
TimerLaunch(_TimerName, 2000);

IF
TimerFinished(_TimerName)
AND
DB_LeaderLib_Treasure_Temp_PartyLeveledUpGenerationTimer(_TimerName, _TreasureID)
THEN
NOT DB_LeaderLib_Treasure_Temp_PartyLeveledUpGenerationTimer(_TimerName, _TreasureID);

PROC
LeaderLib_Requirements_RequirementUnlocked((STRING)_RequirementID)
AND
DB_LeaderLib_Treasure_RegisteredGenerationTypes("REQUIREMENT_UNLOCKED")
AND
LeaderLib_Treasure_QRY_GetTreasureByRequirement(_RequirementID)
AND
DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
AND
LeaderLib_Treasure_QRY_TreasureHasGenerationType(_TreasureID, "REQUIREMENT_UNLOCKED")
AND
LeaderLib_Treasure_QRY_GetTreasureObject(_TreasureID, "REQUIREMENT_UNLOCKED")
AND
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
NOT DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);
LeaderLog_Log("DEBUG", "[LeaderLib:TreasureSystem] Generating [",_TreasureID,"] due to requirement [",_RequirementID,"] unlocking.");
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "REQUIREMENT_UNLOCKED");

PROC
LeaderLib_Requirements_RequirementUnlocked((STRING)_RequirementID)
AND
DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID)
THEN
NOT DB_LeaderLib_Treasure_Temp_MatchedRequirementTreasure(_TreasureID, _RequirementID);
//END_REGION

//REGION TREASURE_FLAG_GEN
QRY
LeaderLib_Treasure_QRY_IsGenerationFlag((STRING)_Flag, (STRING)_FlagType)
AND
DB_LeaderLib_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID)
THEN
NOT DB_LeaderLib_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID);

QRY
LeaderLib_Treasure_QRY_IsGenerationFlag((STRING)_Flag, (STRING)_FlagType)
AND
DB_LeaderLib_Treasure_ItemGenerationFlag(_TreasureID, _ItemEntry, _Flag, _FlagType)
AND
NOT DB_LeaderLib_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID)
THEN
DB_LeaderLib_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID);

PROC
LeaderLib_Treasure_Internal_GenerateByFlag((STRING)_Flag, (STRING)_FlagType)
AND
DB_LeaderLib_Treasure_RegisteredGenerationTypes("FLAG")
AND
LeaderLib_Treasure_QRY_IsGenerationFlag(_Flag, _FlagType)
AND
DB_LeaderLib_Treasure_Temp_FlagToTreasure(_Flag, _FlagType, _TreasureID)
AND
LeaderLib_Treasure_QRY_GetTreasureObject(_TreasureID, "FLAG")
AND
DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID)
THEN
LeaderLib_Treasure_AddToGenerationQueue(_Object, _TreasureID, "FLAG");
NOT DB_LeaderLib_Treasure_Temp_MatchedTreasure(_Object, _TreasureID);
//END_REGION

//REGION CONTAINERS
IF
ObjectFlagSet("LeaderLib_Treasure_GenerationSuccessful", _Object, _)
AND
ItemIsContainer((ITEMGUID)_Object, 1)
THEN
LeaderLib_Treasure_DisableGenerationForObject((GUIDSTRING)_Object);
ObjectClearFlag(_Object, "LeaderLib_Treasure_GenerationSuccessful", 0);
//END_REGION

//REGION DONE_GENERATING
IF
ItemTemplateRemovedFromCharacter(_ItemEntry, _Item, _Object)
AND
DB_LeaderLib_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry)
AND
IsTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly", 1)
THEN
NOT DB_LeaderLib_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry);

IF
ItemTemplateRemovedFromContainer(_ItemEntry, _Item, _Object)
AND
DB_LeaderLib_Treasure_ItemDoneGenerating((GUIDSTRING)_Object, _TreasureID, _ItemEntry)
AND
IsTagged(_Object, "LeaderLib_Treasure_GenerateEndlessly", 1)
THEN
NOT DB_LeaderLib_Treasure_ItemDoneGenerating(_Object, _TreasureID, _ItemEntry);
//END_REGION

//REGION DEBUG
/*
QRY
LeaderLib_Treasure_QRY_Debug_CompareAmounts((STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_GeneratedAmount, (INTEGER)_CurrentAmount)
AND
IntegertoString(_GeneratedAmount, _GenStr)
AND
IntegertoString(_CurrentAmount, _CurStr)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:Debug] Comparing item amounts for [",_TreasureID,":",_ItemEntry,"] - ",_CurStr,"/",_GenStr);
*/

PROC
LeaderLib_Treasure_CountItems((GUIDSTRING)_Object, (STRING)_TreasureID, (STRING)_ItemEntry, (INTEGER)_GeneratedAmount, (STRING)_RequirementID, (INTEGER)_IsStat)
AND
_IsStat <= 0
AND
ItemTemplateIsInCharacterInventory((CHARACTERGUID)_Object, _ItemEntry, _Val)
AND
IntegertoString(_Val, _ValStr)
AND
GetTemplate(_Object, _Template)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:CountItems] Item template [",_TreasureID,"]:[",_ItemEntry,"][",_Template,"] found = ", _ValStr);

/*
IF
StoryEvent(_Object, _Event)
THEN
LeaderLog_Log("DEBUG", "[LeaderLib:Treasure:Debug] Debugging event [",_Event,"]. It is the completion event?");
*/
//END_REGION
EXITSECTION

ENDEXITSECTION
ParentTargetEdge "LaughingLeader__LeaderLib"
